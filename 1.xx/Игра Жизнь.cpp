/*
  Курсовой проект «Игра "Жизнь"»
  Упрощённая консольная реализация игры «Жизнь», придуманная английским
  математиком Джоном Конвеем в 1970 году.

  Содержание
  1. Правила игры
  Место действия игры — Вселенная. Это размеченная на клетки ограниченная
  плоскость.

  Каждая клетка на этой плоскости может находиться в двух состояниях: быть
  «живой», то есть заполненной, или быть «мёртвой», то есть пустой. Клетка имеет
  восемь соседей, окружающих её.

  Распределение живых клеток в начале игры называется первым поколением. Каждое
  следующее поколение рассчитывается на основе предыдущего по правилам:

  В пустой (мёртвой) клетке, рядом с которой ровно три живых клетки, зарождается
  жизнь. Если у живой клетки есть две или три живых соседки, то эта клетка
  продолжает жить. В противном случае, если соседей меньше двух или больше трёх,
  клетка умирает «от одиночества» или «от перенаселённости». Игра прекращается,
  если:

  на поле не останется ни одной «живой» клетки;
  при очередном шаге ни одна из клеток не меняет своего состояния, то есть
  складывается стабильная конфигурация. Игрок не принимает прямого участия в
  игре, а только расставляет начальную конфигурацию «живых» клеток, которые
  затем взаимодействуют согласно правилам уже без его участия. Он является
  наблюдателем.

  2. Требования к решению
  Реализация должна удовлетворять требованиям и ограничениям:

  Текущее состояние Вселенной выводится на консоль в виде таблицы из символов,
  разделённых пробелом. Мёртвая клетка помечается символом -, живая клетка
  помечается символом *. Ниже приведены примеры. На каждом шаге на консоль
  должно выводиться текущее состояние Вселенной, а также информация о номере
  поколения и количестве живых клеток на текущий момент. При завершении игры на
  консоли должно присутствовать состояние Вселенной на момент окончания игры,
  номер поколения, количество живых клеток и причина завершения игры. При
  расчёте состояния клеток на границах игрового поля учитываются только соседние
  клетки. У клеток на границе игрового поля соседних клеток будет меньше 8. Для
  инициализации Вселенной использовать текстовый файл. Файл имеет структуру:
  первые два числа — это количество строк и количество столбцов в сетке
  Вселенной. Затем идёт информация о распределении живых клеток. Распределение
  состоит из неопределённого количества пар чисел, где каждая пара состоит из
  номера строки и номера столбца живой клетки. Примеры входного файла,
  соответствующее ему начальное состояние Вселенной и конечное состояние:

  Пример 1
  20 30
  2 3
  2 4
  3 4
  3 5
  3 6
  3 7
  5 0
  5 1
  5 2
  6 2

  3. Дополнительный материал
  При выводе на консоль каждого следующего состояния у вас никуда не денутся те
  состояния, которые вы выводили ранее. Это может быть полезно для сохранения
  истории развития вашей Вселенной, но при этом может выглядеть не совсем
  эстетично. Альтернативный вариант — очищать консоль перед каждым выводом
  следующего состояния. Для этого можно использовать функцию std::system с
  аргументом "clear", то есть вызвать функцию std::system("clear");. Эта функция
  находится в библиотеке <cstdlib>. Компьютеры сейчас работают быстро, поэтому
  без дополнительных действий состояния будут сменять друг друга практически
  мгновенно. Для комфортного просмотра разумно добавить задержку примерно в одну
  секунду перед каждым следующим вычислением нового состояния. Для этого
  необходимо подключить библиотеку <unistd.h> и использовать функцию sleep,
  которая принимает на вход количество секунд, на которое надо задержаться. Для
  задержки на одну секунду необходимо вызвать sleep(1);.

  4. С чего начать
  Сначала нужно понять, как вы собираетесь хранить информацию о состоянии
  игрового поля. Не забывайте, что нужно хранить предыдущее состояние, чтобы
  иметь возможность сравнить текущее с предыдущим и понять, достигнуто ли одно
  из условий окончания игры.

  Затем реализуйте операции с полем и его ячейками: проверка на количество живых
  соседей, алгоритм изменения состояния ячейки, алгоритм прохода по ячейкам
  поля.

  В конце используйте созданные операции для организации игры по описанному
  алгоритму.
*/
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <unistd.h>

using namespace std;

// Двумерный массив, представляющий вселенную
char **universe;
int rows, cols;
int generation = 0;
int livingCells = 0;

// Инициализация вселенной
void initUniverse() {
  ifstream file("in.txt");
  if (!file.is_open()) {
    cout << "Не удалось открыть файл in.txt" << endl;
    exit(1);
  }

  file >> rows >> cols;
  if (rows <= 0 || cols <= 0) {
    cout << "Некорректные размеры вселенной." << endl;
    exit(1);
  }

  universe = new char *[rows];
  for (int i = 0; i < rows; i++) {
    universe[i] = new char[cols];
    fill(universe[i], universe[i] + cols, '-');
  }

  int row, col;
  while (file >> row >> col) {
    if (row >= 0 && row < rows && col >= 0 && col < cols) {
      universe[row][col] = '*';
      livingCells++;
    } else {
      cout << "Некорректные координаты живой клетки: " << row << ", " << col
           << endl;
    }
  }
  file.close();
}

// Вывод текущего состояния вселенной
void printUniverse() {
  cout << "=====================================================" << endl;
  cout << "Генерация №: " << generation << " | "
       << "Живых клеток: " << livingCells << endl;
  cout << "=====================================================" << endl;
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      cout << universe[i][j] << " ";
    }
    cout << endl;
  }
  sleep(1);
  cout << "\033c"; // Очистка консоли
}

// Подсчет живых соседей для клетки
int countLivingNeighbors(int row, int col) {
  int count = 0;
  for (int i = -1; i <= 1; i++) {
    for (int j = -1; j <= 1; j++) {
      if (i == 0 && j == 0)
        continue; // Пропускаем саму клетку
      int newRow = row + i;
      int newCol = col + j;
      if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
        if (universe[newRow][newCol] == '*') {
          count++;
        }
      }
    }
  }
  return count;
}

// Переход к следующему поколению
bool nextGeneration() {
  char **newUniverse = new char *[rows];
  for (int i = 0; i < rows; i++) {
    newUniverse[i] = new char[cols];
  }

  int newLivingCells = 0; // Счетчик живых клеток в новом поколении

  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      int livingNeighbors = countLivingNeighbors(i, j);
      if (universe[i][j] == '*') {
        // Живая клетка
        if (livingNeighbors < 2 || livingNeighbors > 3) {
          newUniverse[i][j] = '-'; // Клетка умирает
        } else {
          newUniverse[i][j] = '*'; // Клетка живет
          newLivingCells++;
        }
      } else {
        // Мёртвая клетка
        if (livingNeighbors == 3) {
          newUniverse[i][j] = '*'; // Клетка рождается
          newLivingCells++;
        } else {
          newUniverse[i][j] = '-'; // Клетка остаётся мёртвой
        }
      }
    }
  }

  // Проверка стабильности конфигурации
  bool stable = true;
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (universe[i][j] != newUniverse[i][j]) {
        stable = false; // Если есть изменения, конфигурация не стабильна
        break;
      }
    }
    if (!stable)
      break;
  }

  // Освобождение памяти старого состояния
  for (int i = 0; i < rows; i++) {
    delete[] universe[i];
  }
  delete[] universe;

  universe = newUniverse; // Присваиваем новое состояние
  livingCells = newLivingCells; // Обновляем количество живых клеток
  generation++;

  // Проверяем условия окончания игры
  if (livingCells == 0) {
    cout << "=====================================================" << endl;
    cout << "Игра окончена. Генерация №: " << generation << endl;
    cout << "=====================================================" << endl;
    cout << "Вселенная погибла из-за отсутствия живых клеток." << endl;
    printUniverse();
    sleep(10);
    // Освобождение памяти для newUniverse
    for (int i = 0; i < rows; i++) {
      delete[] newUniverse[i];
    }
    delete[] newUniverse;
    exit(0);
  } else if (stable) {
    cout << "=====================================================" << endl;
    cout << "Игра окончена. Генерация №: " << generation << endl;
    cout << "=====================================================" << endl;
    cout << "Вселенная стабильна." << endl;
    printUniverse();
    sleep(10);
    // Освобождение памяти для newUniverse
    for (int i = 0; i < rows; i++) {
      delete[] newUniverse[i];
    }
    delete[] newUniverse;
    exit(0);
  }

  return true; // Если игра продолжается
}

// Цикл для игры
void Game() {
  initUniverse();
  printUniverse();
  while (true) {
    if (!nextGeneration())
      break;
    printUniverse();
  }
}

int main() {
  Game();
  return 0;
}