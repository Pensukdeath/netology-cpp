=============================================================================================================================================================================================
Задача 1. Оценка алгосложности программы
Дан код на языке C++. Ваша задача понять и описать, что он делает, определить его асимптотику, то есть время и дополнительную память, и привести аргументы, почему она именно такая.

int calc(int* arr, int size)
{
  int ans = 0;
  for (int i = 1; i < size; i++)
  {
    ans += arr[i] - arr[i-1];
  }
  return ans;
}
Правила приёма домашней работы
Задание нужно сдавать, указывая сложность алгоритма по скорости и по памяти.
Результатом выполнения задания должен быть текстовый ответ, написание кода не требуется.

=============================================================================================================================================================================================
Разбор кода:
Инициализация переменной ans = 0.
Цикл for (int i = 1; i < size; i++) проходит по массиву, начиная со второго элемента (i = 1).
На каждом шаге вычисляется разность между текущим (arr[i]) и предыдущим (arr[i-1]) элементом, затем эта разность прибавляется к ans.
В конце функция возвращает ans.

Что делает этот код?
Функция фактически вычисляет сумму всех парных разностей между соседними элементами массива, что упрощается до arr[size-1] - arr[0].
Таким образом, результат работы программы — разность между последним и первым элементами массива.

Оценка сложности.
Временная сложность:

Цикл проходит по массиву один раз (от 1 до size-1), выполняя size - 1 итераций.
В каждой итерации выполняется одна операция сложения и вычитания, что является O(1) по времени.
В итоге временная сложность:
O(n)
где n = size.

Дополнительная память:

Используются только переменные ans и i, которые занимают O(1) памяти.
Функция не выделяет дополнительную память (работает in-place).
Итоговая сложность по памяти:
O(1)

Вывод:
Временная сложность: O(n) — линейная зависимость от размера входного массива.
Дополнительная память: O(1) — использование фиксированного количества переменных.

Код работает эффективно и не использует лишнюю память.
=============================================================================================================================================================================================