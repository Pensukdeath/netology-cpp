/*
Задача 1. Снова числа Фибоначчи
Напишите ещё раз программу, которая реализует рекурсивный подсчёт чисел Фибоначчи. Не заглядывайте в ваше предыдущее решение, постарайтесь написать его заново.

Кроме написания кода нужно оценить сложность вашего алгоритма вычисления n-го числа Фибоначчи по скорости и по памяти.

Подсказки
Не читайте этот раздел сразу. Попытайтесь сначала решить задачу самостоятельно :)

Что использовать для решения.
Чтобы оценить сложность алгоритма по скорости, нарисуйте где-нибудь, например, на бумажке, дерево вызовов функции. Постройте деревья вызовов для нескольких небольших значений, идущих подряд, и посмотрите, как меняется это количество. Затем подберите функцию, которая растёт примерно с такой же скоростью.

Правила приёма домашней работы
В личном кабинете для сдачи прикрепите ссылку на repl с кодом для задания, а также укажите сложность алгоритма по скорости и по памяти.
*/

#include <iostream>

using namespace std;

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
	setlocale (LC_ALL, "Russian");
    int n;
    cout << "Введите число n: ";
    cin >> n;
    
    cout << "Число Фибоначчи F(" << n << ") = " << fibonacci(n) << endl;
    
    return 0;
}

/*
Оценка сложности алгоритма:

1. Временная сложность: O(2ⁿ)
   - Алгоритм создаёт дерево рекурсивных вызовов, где каждый вызов порождает ещё два.
   - Общее количество вызовов растёт экспоненциально (примерно как 2^n).
   - Это делает его очень медленным для больших "n".

2. Пространственная сложность: O(n)
   - Глубина рекурсии в худшем случае достигает "n".
   - В стеке вызовов хранятся "n" активных функций.
   - Дополнительная память не используется, кроме стека вызовов.

Вывод: алгоритм неэффективен, так как его сложность O(2ⁿ) делает его непрактичным для больших значений "n". Оптимизировать можно с помощью мемоизации или итеративного подхода.
*/