/*
Задача 2. Ускоряем Фибоначчи
Наивное решение задачи по вычислению чисел Фибоначчи является довольно дорогим по времени, при этом совсем не использует дополнительную память. Давайте исправим это с помощью применения динамического программирования к рекурсии.

Ваша задача — изменить алгоритм вычисления n-го числа Фибоначчи так, чтобы сложность алгоритма по скорости составляла O(n) и по памяти тоже была порядка O(n).

Подсказки
Не читайте этот раздел сразу. Попытайтесь сначала решить задачу самостоятельно :)

Что использовать для решения.
Для уменьшения времени работы алгоритма вычисления n-го числа Фибоначчи вам нужно избавиться от того, что занимает так много времени — вычисления одних и тех же предыдущиих элементов последовательности. Для этого нужно запоминать, например, в массив, уже вычисленные элементы последовательности.

Правила приёма домашней работы
В личном кабинете для сдачи прикрепите ссылку на repl с кодом для задания.
*/

#include <iostream>

using namespace std;

int fibonacci(int n, int memo[]) {
    if (n <= 1) {
        return n;
    }

    if (memo[n] != -1) {
        return memo[n];
    }

    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
    return memo[n];
}

int main() {
	setlocale (LC_ALL, "Russian");
    int n;
    cout << "Введите число n: ";
    cin >> n;

    int* memo = new int[n + 1];
    for (int i = 0; i <= n; i++) {
        memo[i] = -1;
    }

    cout << "Число Фибоначчи F(" << n << ") = " << fibonacci(n, memo) << endl;

    delete[] memo;
    return 0;
}

/*
Оценка сложности алгоритма:

1. Временная сложность: O(n)
   - Благодаря мемоизации, каждое число Фибоначчи вычисляется только один раз.
   - Каждое значение от "0" до "n" сохраняется и используется повторно.
   - Это уменьшает число вызовов функции с O(2ⁿ) до O(n).

2. Пространственная сложность: O(n)
   - Используется массив "memo" размером "n+1" для хранения уже вычисленных значений.
   - Максимальная глубина рекурсии также O(n), так как при каждом вызове "n" уменьшается на 1.

Вывод:  
Этот алгоритм значительно быстрее рекурсивного O(2ⁿ) варианта, но требует O(n) дополнительной памяти.
*/