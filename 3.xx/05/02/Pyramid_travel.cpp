/*
Задача 2. «Путешествие» по пирамиде
Вам нужно организовать «путешествие» пользователя по пирамиде.

Дан массив, в котором хранится пирамида. Ваша задача — дать пользователю возможность «путешествовать» по ней.

В начале программы пользователь начинает свой путь в корне пирамиды. Программа спрашивает пользователя, куда он хочет пойти. Пользователь должен ответить на этот вопрос, используя одну из команд:

up — перейти к родителю;
left — перейти к левому потомку;
right — перейти к правому потомку;
exit — завершить работу программы.
Перед каждым вводом команды программа выводит сообщение Вы находитесь здесь:  и элемент, на котором сейчас находится пользователь. Элемент выводится аналогично тому, как выводились элементы в прошлом задании.

После каждого ввода команды программа выводит результат её выполнения. Если команда была выполнена успешно, выведите на консоль Ок. Если выполнить команду не удалось, например, вы ввели команду up, находясь в корне пирамиды, выведите на консоль сообщение об ошибке и причину её возникновения: например, Ошибка! Отсутствует родитель.

Программа предлагает пользователю вводить команды до тех пор, пока пользователь не введёт команду exit. Если пользователь ввёл команду, которой нет в списке, сообщите ему об этом.

Перед началом работы с пользователем выведите на экран исходный массив в виде массива и в виде пирамиды, как в прошлом задании.

Для проверки работы программы используйте пирамиды:

1 3 6 5 9 8;
94 67 18 44 55 12 6 42;
16 11 9 10 5 6 8 1 2 4.
Подумайте, какие функции стоит создать, чтобы упростить себе работу.

Пример работы программы
Исходный массив: 1 3 6 5 9 8
Пирамида:
0 root 1
1 left(1) 3
1 right(1) 6
2 left(3) 5
2 right(3) 9
2 left(6) 8
Вы находитесь здесь: 0 root 1
Введите команду: right
Ок
Вы находитесь здесь: 1 right(1) 6
Введите команду: right
Ошибка! Отсутствует правый потомок
Вы находитесь здесь: 1 right(1) 6
Введите команду: left
Ок
Вы находитесь здесь: 2 left(6) 8
Введите команду: right
Ошибка! Отсутствует правый потомок
Вы находитесь здесь: 2 left(6) 8
Введите команду: left
Ошибка! Отсутствует левый потомок
Вы находитесь здесь: 2 left(6) 8
Введите команду: up
Ок
Вы находитесь здесь: 1 right(1) 6
Введите команду: up
Ок
Вы находитесь здесь: 0 root 1
Введите команду: up
Ошибка! Отсутствует родитель
Вы находитесь здесь: 0 root 1
Введите команду: exit
Подсказки
Не читайте этот раздел сразу. Попытайтесь сначала решить задачу самостоятельно :)

Что использовать для решения.
Чтобы постоянно спрашивать у пользователя команды и обрабатывать их, нужно использовать цикл do...while и сравнение строк.

Для удобства работы стоит создать функции для получения индекса левого потомка, правого потомка и родителя. Также эти функции должны определять наличие того, чей индекс они вычисляют, то есть у функции фактически будет 2 результата работы. Для этого можно использовать ссылки. Например, функция будет возвращать значение типа bool, а в качестве одного из аргументов принимать переменную по ссылке (или по указателю), в которую будет заносить найденное значение.

Подробности устройства пирамиды на массиве описаны в лекции.
*/

#include <iostream>
#include <string>

using namespace std;

// Функции для вычисления индексов
bool get_parent_index(int index, int &parent_index) {
    if (index == 0) return false;
    parent_index = (index - 1) / 2;
    return true;
}

bool get_left_child_index(int index, int size, int &left_child_index) {
    left_child_index = 2 * index + 1;
    return left_child_index < size;
}

bool get_right_child_index(int index, int size, int &right_child_index) {
    right_child_index = 2 * index + 2;
    return right_child_index < size;
}

// Функция для вывода пирамиды
void print_pyramid(const int heap[], int size) {
    cout << "Пирамида:" << endl;
    for (int i = 0; i < size; i++) {
        int parent_index;
        if (get_parent_index(i, parent_index)) {
            cout << i << " " << (i == 2 * parent_index + 1 ? "left(" : "right(") << heap[parent_index] << ") " << heap[i] << endl;
        } else {
            cout << i << " root " << heap[i] << endl;
        }
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    int heap[] = {1, 3, 6, 5, 9, 8};
    int size = sizeof(heap) / sizeof(heap[0]);
    int current_index = 0;
    string command;

    cout << "Исходный массив: ";
    for (int i = 0; i < size; i++) cout << heap[i] << " ";
    cout << endl;
    
    print_pyramid(heap, size);
    
    do {
        cout << "Вы находитесь здесь: " << current_index << " " << (current_index == 0 ? "root" : (current_index % 2 == 1 ? "left(" : "right(") + to_string(heap[(current_index - 1) / 2]) + ")") << " " << heap[current_index] << endl;
        cout << "Введите команду: ";
        cin >> command;

        if (command == "up") {
            int parent_index;
            if (get_parent_index(current_index, parent_index)) {
                current_index = parent_index;
                cout << "Ок" << endl;
            } else {
                cout << "Ошибка! Отсутствует родитель" << endl;
            }
        } else if (command == "left") {
            int left_child_index;
            if (get_left_child_index(current_index, size, left_child_index)) {
                current_index = left_child_index;
                cout << "Ок" << endl;
            } else {
                cout << "Ошибка! Отсутствует левый потомок" << endl;
            }
        } else if (command == "right") {
            int right_child_index;
            if (get_right_child_index(current_index, size, right_child_index)) {
                current_index = right_child_index;
                cout << "Ок" << endl;
            } else {
                cout << "Ошибка! Отсутствует правый потомок" << endl;
            }
        } else if (command != "exit") {
            cout << "Ошибка! Неизвестная команда" << endl;
        }
    } while (command != "exit");
    
    return 0;
}